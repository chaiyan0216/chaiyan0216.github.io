<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="消息队列" /><meta property="og:locale" content="en" /><meta name="description" content="[toc] 消息队列是一种进程间通信或同一进程的不同线程间的通信方式，直观一点的理解可以直接从字面进行理解，消息队列就是一个容纳消息的队列，producer 有新的消息就丢给队列，consumer 轮询队列进行消息的获取。 高级消息队列协议（Advanced Message Queuing Protocol AMQP）是面向消息中间件提供的开放的应用层协议。 消息队列有很多基于不同协议的开源实现：RabbitMQ（AMQP）、RocketMQ（自定协议）、Kafka（自定的基于TCP的二进制协议）。 RabbitMQ：性能好、延时低、管理界面友好、社区活跃。但吞吐量较低，erlang 语言实现，较难扩展。 RocketMQ：阿里出品，接口简单易用。 Kafka：提供较少的核心功能、具备超高的吞吐量、极高的可用性和拓展性。但存在消息重复消费的缺点，适合于大数据实时计算和日志收集。 消息队列常见的应用场景：异步处理、应用解耦、流量削峰、消息通讯等。 一个模拟 RabbitMQ 的网站：RabbitMQ Simulator AMQP 核心概念 Broker：接收和分发 message 的应用，即 RabbitMQ 的 server。 Virtual Host：出于多用户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似于 namespace 概念。当多个不同的用户使用同一个RabbitMQ server 提供服务时，可以划分出多个 virtual host，每个用户在自己的 virtual host 创建 exchange/queue 等。 Connection： publisher/consumer 和 broker 之间的 TCP 连接。断开连接的操作只会在 client 端进行，broker 不会断开连接，除非出现网络故障或 broker 服务出现问题。 Channel：如果每一次访问 RabbitMQ server 都建立一个 connection，在消息量大的时候建立 TCP connection 的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，channel 作为轻量级的 connection 极大减少了操作系统建立 TCP connection 的开销。 Message：服务器和应用程序之间传送的数据，由 properties 和 body 组成。Properties 可以对 message 进行修饰，比如 message 的优先级、延迟等高级特性，body 就是 message 内容。 Queue：消息最终被送到这里等待 consumer 取走。一个 message 可以被同时拷贝到多个 queue 中。 Exchange： message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发消息到 queue 中去。常用的类型有：direct (point-to-point), topic (publish-subscribe) and fanout (multicast)。 Binding： exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key。Binding 信息被保存到 exchange 中的查询表中，用于 message 的分发依据。 Routing Key：单个路由规则，虚拟机可用它来确定如何路由一个 message。 协议模型 消息流转 Exchange 类型 主要有 3 种类型的 exchange。 Direct Exchange（直连交换机） Topic Exchange（主题交换机） Fanout Exchange（扇型交换机） Direct Exchange 消息传递时，Routing Key 必须完全匹配才会被队列接收，否则该消息会被抛弃。 Topic Exchange 模糊匹配的机制。 * 匹配一个单词 # 匹配零个或多个单词 发送到 topic exchange 的消息会被转发到所有关心 routing key 中指定 topic 的 queue 上 当特殊字符“*”（星号）和“＃”（哈希）未在绑定中使用时，主题交换机的行为就像直接交换机一样。 例如 上图示例创建了三个绑定：Q1 绑定了绑定键 *.orange.*，Q2 绑定了*.*.rabbit 和 lazy.#。 Q1 对所有 orange 感兴趣 Q2 希望听到关于 rabbit 的一切，以及关于 lazy 的一切 那么消息经过 topic exchange 的路由结果将会是如下情况。 quick.orange.rabbit 的消息会同时传递到两个队列 lazy.orange.elephant 的消息也会同事传递到两个队列 quick.orange.fox 只会传递到 Q1 lazy.brown.fox 只会转到 Q2 lazy.pink.rabbit 只会递到 Q2 一次，即使它匹配两个绑定 quick.brown.fox 与任何绑定都不匹配，因此它将被丢弃 lazy.orange.male.rabbit 虽然有四个单词，也会匹配最后一个绑定，并将被传递到 Q2 Fanout Exchange 名字比较形象了，像 fan 一样甩出消息到所有绑定的队列。 不处理 routing key，只需要简单的将队列绑定到交换机上 发送到 fanout exchange 的消息都会被转发到与该交换机绑定的所有队列上 Fanout Exchange 转发消息是最快的 RabbitMQ RabbitMQ 是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。 RabbitMQ 服务器是用 Erlang 语言编写的。 RabbitMQ is a message broker: it accepts and forwards messages. You can think about it as a post office: when you put the mail that you want posting in a post box, you can be sure that Mr. or Ms. Mailperson will eventually deliver the mail to your recipient. In this analogy, RabbitMQ is a post box, a post office and a postman. The major difference between RabbitMQ and the post office is that it doesn’t deal with paper, instead it accepts, stores and forwards binary blobs of data ‒ messages. 安装 官网给了安装指引，MacOS 下用 HomeBrew 比较简单方便，但 Linux 下的步骤稍显凌乱，这里整理下 Ubuntu 的安装步骤。 添加 apt 仓库签名密钥 1 2 3 4 5 6 ## Team RabbitMQ&#39;s main signing key sudo apt-key adv --keyserver &quot;hkps://keys.openpgp.org&quot; --recv-keys &quot;0x0A9AF2115F4687BD29803A206B73A36E6026DFCA&quot; ## Launchpad PPA that provides modern Erlang releases sudo apt-key adv --keyserver &quot;keyserver.ubuntu.com&quot; --recv-keys &quot;F77F1EDA57EBB1CC&quot; ## PackageCloud RabbitMQ repository curl -1sLf &#39;https://packagecloud.io/rabbitmq/rabbitmq-server/gpgkey&#39; | apt-key add - 安装 apt-transport-https，以便能够从 PackageCloud、Cloudsmith.io、Launchpad 下载 RabbitMQ 和 Erlang 的包文件 1 sudo apt-get install apt-transport-https 添加第三方软件源，将以下内容添加至 /etc/apt/sources.list.d/rabbitmq.list，需要注意不同的 Ubuntu 版本的 distribution name 有差别。 focal for Ubuntu 20.04 bionic for Ubuntu 18.04 xenial for Ubuntu 16.04 buster for Debian Buster 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # Source repository definition example. ## Provides modern Erlang/OTP releases ## ## &quot;bionic&quot; as distribution name should work for any reasonably recent Ubuntu or Debian release. ## See the release to distribution mapping table in RabbitMQ doc guides to learn more. deb http://ppa.launchpad.net/rabbitmq/rabbitmq-erlang/ubuntu bionic main deb-src http://ppa.launchpad.net/rabbitmq/rabbitmq-erlang/ubuntu bionic main ## Provides RabbitMQ ## ## &quot;bionic&quot; as distribution name should work for any reasonably recent Ubuntu or Debian release. ## See the release to distribution mapping table in RabbitMQ doc guides to learn more. deb https://packagecloud.io/rabbitmq/rabbitmq-server/ubuntu/ bionic main deb-src https://packagecloud.io/rabbitmq/rabbitmq-server/ubuntu/ bionic main 安装 RabbitMQ 及其相关依赖的包 1 2 3 4 5 6 7 8 9 10 11 12 ## Update package indices sudo apt-get update -y ## Install Erlang packages sudo apt-get install -y erlang-base \ erlang-asn1 erlang-crypto erlang-eldap erlang-ftp erlang-inets \ erlang-mnesia erlang-os-mon erlang-parsetools erlang-public-key \ erlang-runtime-tools erlang-snmp erlang-ssl \ erlang-syntax-tools erlang-tftp erlang-tools erlang-xmerl ## Install rabbitmq-server and its dependencies sudo apt-get install rabbitmq-server -y --fix-missing 启停和界面 1 2 3 4 5 6 7 8 9 10 11 # 启动 sudo service rabbitmq-server start # 停止 sudo service rabbitmq-server stop # 重启 sudo service rabbitmq-server restart # 查看当前状态 sudo service rabbitmq-server status RabbitMQ 提供了一个管理插件（rabbitmq_management），方便在 web 端管理 RabbitMQ，默认未开启需要在命令行开启该插件。开启插件并重启 RabbitMQ server 后，就可以通过浏览器进行管理，默认端口是 15672。 1 2 # 开启管理工具，然后重启服务即可通过 web 进行管理 sudo rabbitmq-plugins enable rabbitmq_management 默认有一个 guest/guest 的用户可以用来登录管理工具，同时也可以通过命令新建用户和赋予权限。 1 2 3 4 5 # 添加 admin/admin 用户 sudo rabbitmqctl add_user admin admin # 赋予其管理员权限 sudo rabbitmqctl set_user_tags admin administrator 示例 官网的一些开发示例：RabbitMQ Tutorials" /><meta property="og:description" content="[toc] 消息队列是一种进程间通信或同一进程的不同线程间的通信方式，直观一点的理解可以直接从字面进行理解，消息队列就是一个容纳消息的队列，producer 有新的消息就丢给队列，consumer 轮询队列进行消息的获取。 高级消息队列协议（Advanced Message Queuing Protocol AMQP）是面向消息中间件提供的开放的应用层协议。 消息队列有很多基于不同协议的开源实现：RabbitMQ（AMQP）、RocketMQ（自定协议）、Kafka（自定的基于TCP的二进制协议）。 RabbitMQ：性能好、延时低、管理界面友好、社区活跃。但吞吐量较低，erlang 语言实现，较难扩展。 RocketMQ：阿里出品，接口简单易用。 Kafka：提供较少的核心功能、具备超高的吞吐量、极高的可用性和拓展性。但存在消息重复消费的缺点，适合于大数据实时计算和日志收集。 消息队列常见的应用场景：异步处理、应用解耦、流量削峰、消息通讯等。 一个模拟 RabbitMQ 的网站：RabbitMQ Simulator AMQP 核心概念 Broker：接收和分发 message 的应用，即 RabbitMQ 的 server。 Virtual Host：出于多用户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似于 namespace 概念。当多个不同的用户使用同一个RabbitMQ server 提供服务时，可以划分出多个 virtual host，每个用户在自己的 virtual host 创建 exchange/queue 等。 Connection： publisher/consumer 和 broker 之间的 TCP 连接。断开连接的操作只会在 client 端进行，broker 不会断开连接，除非出现网络故障或 broker 服务出现问题。 Channel：如果每一次访问 RabbitMQ server 都建立一个 connection，在消息量大的时候建立 TCP connection 的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，channel 作为轻量级的 connection 极大减少了操作系统建立 TCP connection 的开销。 Message：服务器和应用程序之间传送的数据，由 properties 和 body 组成。Properties 可以对 message 进行修饰，比如 message 的优先级、延迟等高级特性，body 就是 message 内容。 Queue：消息最终被送到这里等待 consumer 取走。一个 message 可以被同时拷贝到多个 queue 中。 Exchange： message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发消息到 queue 中去。常用的类型有：direct (point-to-point), topic (publish-subscribe) and fanout (multicast)。 Binding： exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key。Binding 信息被保存到 exchange 中的查询表中，用于 message 的分发依据。 Routing Key：单个路由规则，虚拟机可用它来确定如何路由一个 message。 协议模型 消息流转 Exchange 类型 主要有 3 种类型的 exchange。 Direct Exchange（直连交换机） Topic Exchange（主题交换机） Fanout Exchange（扇型交换机） Direct Exchange 消息传递时，Routing Key 必须完全匹配才会被队列接收，否则该消息会被抛弃。 Topic Exchange 模糊匹配的机制。 * 匹配一个单词 # 匹配零个或多个单词 发送到 topic exchange 的消息会被转发到所有关心 routing key 中指定 topic 的 queue 上 当特殊字符“*”（星号）和“＃”（哈希）未在绑定中使用时，主题交换机的行为就像直接交换机一样。 例如 上图示例创建了三个绑定：Q1 绑定了绑定键 *.orange.*，Q2 绑定了*.*.rabbit 和 lazy.#。 Q1 对所有 orange 感兴趣 Q2 希望听到关于 rabbit 的一切，以及关于 lazy 的一切 那么消息经过 topic exchange 的路由结果将会是如下情况。 quick.orange.rabbit 的消息会同时传递到两个队列 lazy.orange.elephant 的消息也会同事传递到两个队列 quick.orange.fox 只会传递到 Q1 lazy.brown.fox 只会转到 Q2 lazy.pink.rabbit 只会递到 Q2 一次，即使它匹配两个绑定 quick.brown.fox 与任何绑定都不匹配，因此它将被丢弃 lazy.orange.male.rabbit 虽然有四个单词，也会匹配最后一个绑定，并将被传递到 Q2 Fanout Exchange 名字比较形象了，像 fan 一样甩出消息到所有绑定的队列。 不处理 routing key，只需要简单的将队列绑定到交换机上 发送到 fanout exchange 的消息都会被转发到与该交换机绑定的所有队列上 Fanout Exchange 转发消息是最快的 RabbitMQ RabbitMQ 是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。 RabbitMQ 服务器是用 Erlang 语言编写的。 RabbitMQ is a message broker: it accepts and forwards messages. You can think about it as a post office: when you put the mail that you want posting in a post box, you can be sure that Mr. or Ms. Mailperson will eventually deliver the mail to your recipient. In this analogy, RabbitMQ is a post box, a post office and a postman. The major difference between RabbitMQ and the post office is that it doesn’t deal with paper, instead it accepts, stores and forwards binary blobs of data ‒ messages. 安装 官网给了安装指引，MacOS 下用 HomeBrew 比较简单方便，但 Linux 下的步骤稍显凌乱，这里整理下 Ubuntu 的安装步骤。 添加 apt 仓库签名密钥 1 2 3 4 5 6 ## Team RabbitMQ&#39;s main signing key sudo apt-key adv --keyserver &quot;hkps://keys.openpgp.org&quot; --recv-keys &quot;0x0A9AF2115F4687BD29803A206B73A36E6026DFCA&quot; ## Launchpad PPA that provides modern Erlang releases sudo apt-key adv --keyserver &quot;keyserver.ubuntu.com&quot; --recv-keys &quot;F77F1EDA57EBB1CC&quot; ## PackageCloud RabbitMQ repository curl -1sLf &#39;https://packagecloud.io/rabbitmq/rabbitmq-server/gpgkey&#39; | apt-key add - 安装 apt-transport-https，以便能够从 PackageCloud、Cloudsmith.io、Launchpad 下载 RabbitMQ 和 Erlang 的包文件 1 sudo apt-get install apt-transport-https 添加第三方软件源，将以下内容添加至 /etc/apt/sources.list.d/rabbitmq.list，需要注意不同的 Ubuntu 版本的 distribution name 有差别。 focal for Ubuntu 20.04 bionic for Ubuntu 18.04 xenial for Ubuntu 16.04 buster for Debian Buster 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # Source repository definition example. ## Provides modern Erlang/OTP releases ## ## &quot;bionic&quot; as distribution name should work for any reasonably recent Ubuntu or Debian release. ## See the release to distribution mapping table in RabbitMQ doc guides to learn more. deb http://ppa.launchpad.net/rabbitmq/rabbitmq-erlang/ubuntu bionic main deb-src http://ppa.launchpad.net/rabbitmq/rabbitmq-erlang/ubuntu bionic main ## Provides RabbitMQ ## ## &quot;bionic&quot; as distribution name should work for any reasonably recent Ubuntu or Debian release. ## See the release to distribution mapping table in RabbitMQ doc guides to learn more. deb https://packagecloud.io/rabbitmq/rabbitmq-server/ubuntu/ bionic main deb-src https://packagecloud.io/rabbitmq/rabbitmq-server/ubuntu/ bionic main 安装 RabbitMQ 及其相关依赖的包 1 2 3 4 5 6 7 8 9 10 11 12 ## Update package indices sudo apt-get update -y ## Install Erlang packages sudo apt-get install -y erlang-base \ erlang-asn1 erlang-crypto erlang-eldap erlang-ftp erlang-inets \ erlang-mnesia erlang-os-mon erlang-parsetools erlang-public-key \ erlang-runtime-tools erlang-snmp erlang-ssl \ erlang-syntax-tools erlang-tftp erlang-tools erlang-xmerl ## Install rabbitmq-server and its dependencies sudo apt-get install rabbitmq-server -y --fix-missing 启停和界面 1 2 3 4 5 6 7 8 9 10 11 # 启动 sudo service rabbitmq-server start # 停止 sudo service rabbitmq-server stop # 重启 sudo service rabbitmq-server restart # 查看当前状态 sudo service rabbitmq-server status RabbitMQ 提供了一个管理插件（rabbitmq_management），方便在 web 端管理 RabbitMQ，默认未开启需要在命令行开启该插件。开启插件并重启 RabbitMQ server 后，就可以通过浏览器进行管理，默认端口是 15672。 1 2 # 开启管理工具，然后重启服务即可通过 web 进行管理 sudo rabbitmq-plugins enable rabbitmq_management 默认有一个 guest/guest 的用户可以用来登录管理工具，同时也可以通过命令新建用户和赋予权限。 1 2 3 4 5 # 添加 admin/admin 用户 sudo rabbitmqctl add_user admin admin # 赋予其管理员权限 sudo rabbitmqctl set_user_tags admin administrator 示例 官网的一些开发示例：RabbitMQ Tutorials" /><link rel="canonical" href="/tool/posts/message_queue/" /><meta property="og:url" content="/tool/posts/message_queue/" /><meta property="og:site_name" content="Chai Yan" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-05-06T00:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="消息队列" /><meta name="twitter:site" content="@twitter_username" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2021-05-06T00:00:00+08:00","datePublished":"2021-05-06T00:00:00+08:00","description":"[toc] 消息队列是一种进程间通信或同一进程的不同线程间的通信方式，直观一点的理解可以直接从字面进行理解，消息队列就是一个容纳消息的队列，producer 有新的消息就丢给队列，consumer 轮询队列进行消息的获取。 高级消息队列协议（Advanced Message Queuing Protocol AMQP）是面向消息中间件提供的开放的应用层协议。 消息队列有很多基于不同协议的开源实现：RabbitMQ（AMQP）、RocketMQ（自定协议）、Kafka（自定的基于TCP的二进制协议）。 RabbitMQ：性能好、延时低、管理界面友好、社区活跃。但吞吐量较低，erlang 语言实现，较难扩展。 RocketMQ：阿里出品，接口简单易用。 Kafka：提供较少的核心功能、具备超高的吞吐量、极高的可用性和拓展性。但存在消息重复消费的缺点，适合于大数据实时计算和日志收集。 消息队列常见的应用场景：异步处理、应用解耦、流量削峰、消息通讯等。 一个模拟 RabbitMQ 的网站：RabbitMQ Simulator AMQP 核心概念 Broker：接收和分发 message 的应用，即 RabbitMQ 的 server。 Virtual Host：出于多用户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似于 namespace 概念。当多个不同的用户使用同一个RabbitMQ server 提供服务时，可以划分出多个 virtual host，每个用户在自己的 virtual host 创建 exchange/queue 等。 Connection： publisher/consumer 和 broker 之间的 TCP 连接。断开连接的操作只会在 client 端进行，broker 不会断开连接，除非出现网络故障或 broker 服务出现问题。 Channel：如果每一次访问 RabbitMQ server 都建立一个 connection，在消息量大的时候建立 TCP connection 的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，channel 作为轻量级的 connection 极大减少了操作系统建立 TCP connection 的开销。 Message：服务器和应用程序之间传送的数据，由 properties 和 body 组成。Properties 可以对 message 进行修饰，比如 message 的优先级、延迟等高级特性，body 就是 message 内容。 Queue：消息最终被送到这里等待 consumer 取走。一个 message 可以被同时拷贝到多个 queue 中。 Exchange： message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发消息到 queue 中去。常用的类型有：direct (point-to-point), topic (publish-subscribe) and fanout (multicast)。 Binding： exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key。Binding 信息被保存到 exchange 中的查询表中，用于 message 的分发依据。 Routing Key：单个路由规则，虚拟机可用它来确定如何路由一个 message。 协议模型 消息流转 Exchange 类型 主要有 3 种类型的 exchange。 Direct Exchange（直连交换机） Topic Exchange（主题交换机） Fanout Exchange（扇型交换机） Direct Exchange 消息传递时，Routing Key 必须完全匹配才会被队列接收，否则该消息会被抛弃。 Topic Exchange 模糊匹配的机制。 * 匹配一个单词 # 匹配零个或多个单词 发送到 topic exchange 的消息会被转发到所有关心 routing key 中指定 topic 的 queue 上 当特殊字符“*”（星号）和“＃”（哈希）未在绑定中使用时，主题交换机的行为就像直接交换机一样。 例如 上图示例创建了三个绑定：Q1 绑定了绑定键 *.orange.*，Q2 绑定了*.*.rabbit 和 lazy.#。 Q1 对所有 orange 感兴趣 Q2 希望听到关于 rabbit 的一切，以及关于 lazy 的一切 那么消息经过 topic exchange 的路由结果将会是如下情况。 quick.orange.rabbit 的消息会同时传递到两个队列 lazy.orange.elephant 的消息也会同事传递到两个队列 quick.orange.fox 只会传递到 Q1 lazy.brown.fox 只会转到 Q2 lazy.pink.rabbit 只会递到 Q2 一次，即使它匹配两个绑定 quick.brown.fox 与任何绑定都不匹配，因此它将被丢弃 lazy.orange.male.rabbit 虽然有四个单词，也会匹配最后一个绑定，并将被传递到 Q2 Fanout Exchange 名字比较形象了，像 fan 一样甩出消息到所有绑定的队列。 不处理 routing key，只需要简单的将队列绑定到交换机上 发送到 fanout exchange 的消息都会被转发到与该交换机绑定的所有队列上 Fanout Exchange 转发消息是最快的 RabbitMQ RabbitMQ 是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。 RabbitMQ 服务器是用 Erlang 语言编写的。 RabbitMQ is a message broker: it accepts and forwards messages. You can think about it as a post office: when you put the mail that you want posting in a post box, you can be sure that Mr. or Ms. Mailperson will eventually deliver the mail to your recipient. In this analogy, RabbitMQ is a post box, a post office and a postman. The major difference between RabbitMQ and the post office is that it doesn’t deal with paper, instead it accepts, stores and forwards binary blobs of data ‒ messages. 安装 官网给了安装指引，MacOS 下用 HomeBrew 比较简单方便，但 Linux 下的步骤稍显凌乱，这里整理下 Ubuntu 的安装步骤。 添加 apt 仓库签名密钥 1 2 3 4 5 6 ## Team RabbitMQ&#39;s main signing key sudo apt-key adv --keyserver &quot;hkps://keys.openpgp.org&quot; --recv-keys &quot;0x0A9AF2115F4687BD29803A206B73A36E6026DFCA&quot; ## Launchpad PPA that provides modern Erlang releases sudo apt-key adv --keyserver &quot;keyserver.ubuntu.com&quot; --recv-keys &quot;F77F1EDA57EBB1CC&quot; ## PackageCloud RabbitMQ repository curl -1sLf &#39;https://packagecloud.io/rabbitmq/rabbitmq-server/gpgkey&#39; | apt-key add - 安装 apt-transport-https，以便能够从 PackageCloud、Cloudsmith.io、Launchpad 下载 RabbitMQ 和 Erlang 的包文件 1 sudo apt-get install apt-transport-https 添加第三方软件源，将以下内容添加至 /etc/apt/sources.list.d/rabbitmq.list，需要注意不同的 Ubuntu 版本的 distribution name 有差别。 focal for Ubuntu 20.04 bionic for Ubuntu 18.04 xenial for Ubuntu 16.04 buster for Debian Buster 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # Source repository definition example. ## Provides modern Erlang/OTP releases ## ## &quot;bionic&quot; as distribution name should work for any reasonably recent Ubuntu or Debian release. ## See the release to distribution mapping table in RabbitMQ doc guides to learn more. deb http://ppa.launchpad.net/rabbitmq/rabbitmq-erlang/ubuntu bionic main deb-src http://ppa.launchpad.net/rabbitmq/rabbitmq-erlang/ubuntu bionic main ## Provides RabbitMQ ## ## &quot;bionic&quot; as distribution name should work for any reasonably recent Ubuntu or Debian release. ## See the release to distribution mapping table in RabbitMQ doc guides to learn more. deb https://packagecloud.io/rabbitmq/rabbitmq-server/ubuntu/ bionic main deb-src https://packagecloud.io/rabbitmq/rabbitmq-server/ubuntu/ bionic main 安装 RabbitMQ 及其相关依赖的包 1 2 3 4 5 6 7 8 9 10 11 12 ## Update package indices sudo apt-get update -y ## Install Erlang packages sudo apt-get install -y erlang-base \\ erlang-asn1 erlang-crypto erlang-eldap erlang-ftp erlang-inets \\ erlang-mnesia erlang-os-mon erlang-parsetools erlang-public-key \\ erlang-runtime-tools erlang-snmp erlang-ssl \\ erlang-syntax-tools erlang-tftp erlang-tools erlang-xmerl ## Install rabbitmq-server and its dependencies sudo apt-get install rabbitmq-server -y --fix-missing 启停和界面 1 2 3 4 5 6 7 8 9 10 11 # 启动 sudo service rabbitmq-server start # 停止 sudo service rabbitmq-server stop # 重启 sudo service rabbitmq-server restart # 查看当前状态 sudo service rabbitmq-server status RabbitMQ 提供了一个管理插件（rabbitmq_management），方便在 web 端管理 RabbitMQ，默认未开启需要在命令行开启该插件。开启插件并重启 RabbitMQ server 后，就可以通过浏览器进行管理，默认端口是 15672。 1 2 # 开启管理工具，然后重启服务即可通过 web 进行管理 sudo rabbitmq-plugins enable rabbitmq_management 默认有一个 guest/guest 的用户可以用来登录管理工具，同时也可以通过命令新建用户和赋予权限。 1 2 3 4 5 # 添加 admin/admin 用户 sudo rabbitmqctl add_user admin admin # 赋予其管理员权限 sudo rabbitmqctl set_user_tags admin administrator 示例 官网的一些开发示例：RabbitMQ Tutorials","headline":"消息队列","mainEntityOfPage":{"@type":"WebPage","@id":"/tool/posts/message_queue/"},"url":"/tool/posts/message_queue/"}</script><title>消息队列 | Chai Yan</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Chai Yan"><meta name="application-name" content="Chai Yan"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/img/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Chai Yan</a></div><div class="site-subtitle font-italic">Personal technical blog, recording interesting things.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/chaiyan0216" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['chaiyan2046','163.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>消息队列</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>消息队列</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1620230400" data-df="ll" data-toggle="tooltip" data-placement="bottom"> May 6, 2021 </em> </span><div class="d-flex justify-content-between"> <span> By <em> <a href="https://github.com/chaiyao0216">Chai Yan</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1903 words"> <em>10 min</em> read</span></div></div></div><div class="post-content"><p>[toc]</p><p><a href="https://zh.wikipedia.org/wiki/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97">消息队列</a>是一种进程间通信或同一进程的不同线程间的通信方式，直观一点的理解可以直接从字面进行理解，消息队列就是一个容纳消息的队列，producer 有新的消息就丢给队列，consumer 轮询队列进行消息的获取。</p><p><a href="https://zh.wikipedia.org/wiki/%E9%AB%98%E7%BA%A7%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%8D%8F%E8%AE%AE">高级消息队列协议</a>（Advanced Message Queuing Protocol AMQP）是面向消息中间件提供的开放的应用层协议。</p><p>消息队列有很多基于不同协议的开源实现：RabbitMQ（AMQP）、RocketMQ（自定协议）、Kafka（自定的基于TCP的二进制协议）。</p><ul><li>RabbitMQ：性能好、延时低、管理界面友好、社区活跃。但吞吐量较低，erlang 语言实现，较难扩展。<li>RocketMQ：阿里出品，接口简单易用。<li>Kafka：提供较少的核心功能、具备超高的吞吐量、极高的可用性和拓展性。但存在消息重复消费的缺点，适合于大数据实时计算和日志收集。</ul><p>消息队列常见的应用场景：异步处理、应用解耦、流量削峰、消息通讯等。</p><p>一个模拟 RabbitMQ 的网站：<a href="http://tryrabbitmq.com/">RabbitMQ Simulator</a></p><h4 id="amqp-核心概念"><span class="mr-2">AMQP 核心概念</span><a href="#amqp-核心概念" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li><p><strong>Broker</strong>：接收和分发 message 的应用，即 RabbitMQ 的 server。</p><li><p><strong>Virtual Host</strong>：出于多用户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似于 namespace 概念。当多个不同的用户使用同一个RabbitMQ server 提供服务时，可以划分出多个 virtual host，每个用户在自己的 virtual host 创建 exchange/queue 等。</p><li><p><strong>Connection</strong>： publisher/consumer 和 broker 之间的 TCP 连接。断开连接的操作只会在 client 端进行，broker 不会断开连接，除非出现网络故障或 broker 服务出现问题。</p><li><p><strong>Channel</strong>：如果每一次访问 RabbitMQ server 都建立一个 connection，在消息量大的时候建立 TCP connection 的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，channel 作为轻量级的 connection 极大减少了操作系统建立 TCP connection 的开销。</p><li><p><strong>Message</strong>：服务器和应用程序之间传送的数据，由 properties 和 body 组成。Properties 可以对 message 进行修饰，比如 message 的优先级、延迟等高级特性，body 就是 message 内容。</p><li><p><strong>Queue</strong>：消息最终被送到这里等待 consumer 取走。一个 message 可以被同时拷贝到多个 queue 中。</p><li><p><strong>Exchange</strong>： message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发消息到 queue 中去。常用的类型有：direct (point-to-point), topic (publish-subscribe) and fanout (multicast)。</p><li><p><strong>Binding</strong>： exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key。Binding 信息被保存到 exchange 中的查询表中，用于 message 的分发依据。</p><li><p><strong>Routing Key</strong>：单个路由规则，虚拟机可用它来确定如何路由一个 message。</p></ul><p><strong>协议模型</strong></p><p><img data-src="/images/amqp-arch1.png" style="zoom: 67%;" data-proofer-ignore></p><p><img data-src="/images/amqp-arch2.png" alt="" data-proofer-ignore></p><p><strong>消息流转</strong></p><p><img data-src="/images/amqp-message-flow.jpg" style="zoom:67%;" data-proofer-ignore></p><h4 id="exchange-类型"><span class="mr-2">Exchange 类型</span><a href="#exchange-类型" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>主要有 3 种类型的 exchange。</p><ul><li>Direct Exchange（直连交换机）<li>Topic Exchange（主题交换机）<li>Fanout Exchange（扇型交换机）</ul><h5 id="direct-exchange"><span class="mr-2">Direct Exchange</span><a href="#direct-exchange" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><p>消息传递时，Routing Key 必须完全匹配才会被队列接收，否则该消息会被抛弃。</p><p><img data-src="/images/direct-exchange.png" style="zoom:40%;" data-proofer-ignore></p><h5 id="topic-exchange"><span class="mr-2">Topic Exchange</span><a href="#topic-exchange" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><p>模糊匹配的机制。</p><ul><li>* 匹配一个单词<li># 匹配零个或多个单词<li>发送到 topic exchange 的消息会被转发到所有关心 routing key 中指定 topic 的 queue 上<li>当特殊字符“*”（星号）和“＃”（哈希）未在绑定中使用时，主题交换机的行为就像直接交换机一样。</ul><p><img data-src="/images/topic-exchange.png" style="zoom:40%;" data-proofer-ignore></p><p><strong>例如</strong></p><p><img data-src="/images/topic-exchange-example.png" alt="" data-proofer-ignore></p><p>上图示例创建了三个绑定：Q1 绑定了绑定键 <code class="language-plaintext highlighter-rouge">*.orange.*</code>，Q2 绑定了<code class="language-plaintext highlighter-rouge">*.*.rabbit</code> 和 <code class="language-plaintext highlighter-rouge">lazy.#</code>。</p><ul><li>Q1 对所有 <strong>orange</strong> 感兴趣<li>Q2 希望听到关于 <strong>rabbit</strong> 的一切，以及关于 <strong>lazy</strong> 的一切</ul><p>那么消息经过 topic exchange 的路由结果将会是如下情况。</p><ul><li>quick.orange.rabbit 的消息会同时传递到两个队列<li><p>lazy.orange.elephant 的消息也会同事传递到两个队列</p><li>quick.orange.fox 只会传递到 Q1<li>lazy.brown.fox 只会转到 Q2<li>lazy.pink.rabbit 只会递到 Q2 一次，即使它匹配两个绑定<li>quick.brown.fox 与任何绑定都不匹配，因此它将被丢弃<li>lazy.orange.male.rabbit 虽然有四个单词，也会匹配最后一个绑定，并将被传递到 Q2</ul><h5 id="fanout-exchange"><span class="mr-2">Fanout Exchange</span><a href="#fanout-exchange" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><p>名字比较形象了，像 fan 一样甩出消息到所有绑定的队列。</p><ul><li>不处理 routing key，只需要简单的将队列绑定到交换机上<li>发送到 fanout exchange 的消息都会被转发到与该交换机绑定的所有队列上<li>Fanout Exchange 转发消息是最快的</ul><p><img data-src="/images/fanout-exchange.png" style="zoom:40%;" data-proofer-ignore></p><h4 id="rabbitmq"><span class="mr-2">RabbitMQ</span><a href="#rabbitmq" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><a href="https://www.rabbitmq.com/">RabbitMQ</a> 是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。</p><p>RabbitMQ 服务器是用 <a href="https://www.erlang.org/">Erlang</a> 语言编写的。</p><blockquote><p>RabbitMQ is a message broker: it accepts and forwards messages. You can think about it as a post office: when you put the mail that you want posting in a post box, you can be sure that Mr. or Ms. Mailperson will eventually deliver the mail to your recipient. In this analogy, RabbitMQ is a post box, a post office and a postman.</p><p>The major difference between RabbitMQ and the post office is that it doesn’t deal with paper, instead it accepts, stores and forwards binary blobs of data ‒ <em>messages</em>.</p></blockquote><h5 id="安装"><span class="mr-2">安装</span><a href="#安装" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><p>官网给了<a href="https://www.rabbitmq.com/download.html">安装指引</a>，MacOS 下用 HomeBrew 比较简单方便，但 Linux 下的步骤稍显凌乱，这里整理下 Ubuntu 的安装步骤。</p><ol><li><p>添加 apt 仓库签名密钥</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="c">## Team RabbitMQ's main signing key</span>
<span class="nb">sudo </span>apt-key adv <span class="nt">--keyserver</span> <span class="s2">"hkps://keys.openpgp.org"</span> <span class="nt">--recv-keys</span> <span class="s2">"0x0A9AF2115F4687BD29803A206B73A36E6026DFCA"</span>
<span class="c">## Launchpad PPA that provides modern Erlang releases</span>
<span class="nb">sudo </span>apt-key adv <span class="nt">--keyserver</span> <span class="s2">"keyserver.ubuntu.com"</span> <span class="nt">--recv-keys</span> <span class="s2">"F77F1EDA57EBB1CC"</span>
<span class="c">## PackageCloud RabbitMQ repository</span>
curl <span class="nt">-1sLf</span> <span class="s1">'https://packagecloud.io/rabbitmq/rabbitmq-server/gpgkey'</span> | apt-key add -
</pre></table></code></div></div><li><p>安装 <code class="language-plaintext highlighter-rouge">apt-transport-https</code>，以便能够从 PackageCloud、Cloudsmith.io、Launchpad 下载 RabbitMQ 和 Erlang 的包文件</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nb">sudo </span>apt-get <span class="nb">install </span>apt-transport-https
</pre></table></code></div></div><li><p>添加第三方软件源，将以下内容添加至 <code class="language-plaintext highlighter-rouge">/etc/apt/sources.list.d/rabbitmq.list</code>，需要注意不同的 Ubuntu 版本的 distribution name 有差别。</p><ul><li><code class="language-plaintext highlighter-rouge">focal</code> for Ubuntu 20.04<li><code class="language-plaintext highlighter-rouge">bionic</code> for Ubuntu 18.04<li><code class="language-plaintext highlighter-rouge">xenial</code> for Ubuntu 16.04<li><code class="language-plaintext highlighter-rouge">buster</code> for Debian Buster</ul><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="c"># Source repository definition example.</span>
   
<span class="c">## Provides modern Erlang/OTP releases</span>
<span class="c">##</span>
<span class="c">## "bionic" as distribution name should work for any reasonably recent Ubuntu or Debian release.</span>
<span class="c">## See the release to distribution mapping table in RabbitMQ doc guides to learn more.</span>
deb http://ppa.launchpad.net/rabbitmq/rabbitmq-erlang/ubuntu bionic main
deb-src http://ppa.launchpad.net/rabbitmq/rabbitmq-erlang/ubuntu bionic main
   
<span class="c">## Provides RabbitMQ</span>
<span class="c">##</span>
<span class="c">## "bionic" as distribution name should work for any reasonably recent Ubuntu or Debian release.</span>
<span class="c">## See the release to distribution mapping table in RabbitMQ doc guides to learn more.</span>
deb https://packagecloud.io/rabbitmq/rabbitmq-server/ubuntu/ bionic main
deb-src https://packagecloud.io/rabbitmq/rabbitmq-server/ubuntu/ bionic main
</pre></table></code></div></div><li><p>安装 RabbitMQ 及其相关依赖的包</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="c">## Update package indices</span>
<span class="nb">sudo </span>apt-get update <span class="nt">-y</span>
   
<span class="c">## Install Erlang packages</span>
<span class="nb">sudo </span>apt-get <span class="nb">install</span> <span class="nt">-y</span> erlang-base <span class="se">\</span>
                        erlang-asn1 erlang-crypto erlang-eldap erlang-ftp erlang-inets <span class="se">\</span>
                        erlang-mnesia erlang-os-mon erlang-parsetools erlang-public-key <span class="se">\</span>
                        erlang-runtime-tools erlang-snmp erlang-ssl <span class="se">\</span>
                        erlang-syntax-tools erlang-tftp erlang-tools erlang-xmerl
   
<span class="c">## Install rabbitmq-server and its dependencies</span>
<span class="nb">sudo </span>apt-get <span class="nb">install </span>rabbitmq-server <span class="nt">-y</span> <span class="nt">--fix-missing</span>
</pre></table></code></div></div></ol><h5 id="启停和界面"><span class="mr-2">启停和界面</span><a href="#启停和界面" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="c"># 启动</span>
<span class="nb">sudo </span>service rabbitmq-server start

<span class="c"># 停止</span>
<span class="nb">sudo </span>service rabbitmq-server stop 

<span class="c"># 重启</span>
<span class="nb">sudo </span>service rabbitmq-server restart 

<span class="c"># 查看当前状态</span>
<span class="nb">sudo </span>service rabbitmq-server status 
</pre></table></code></div></div><p>RabbitMQ 提供了一个管理插件（rabbitmq_management），方便在 web 端管理 RabbitMQ，默认未开启需要在命令行开启该插件。开启插件并重启 RabbitMQ server 后，就可以通过浏览器进行管理，默认端口是 15672。</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="c"># 开启管理工具，然后重启服务即可通过 web 进行管理</span>
<span class="nb">sudo </span>rabbitmq-plugins <span class="nb">enable </span>rabbitmq_management
</pre></table></code></div></div><p>默认有一个 guest/guest 的用户可以用来登录管理工具，同时也可以通过命令新建用户和赋予权限。</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c"># 添加 admin/admin 用户</span>
<span class="nb">sudo </span>rabbitmqctl add_user admin admin

<span class="c"># 赋予其管理员权限</span>
<span class="nb">sudo </span>rabbitmqctl set_user_tags admin administrator 
</pre></table></code></div></div><h5 id="示例"><span class="mr-2">示例</span><a href="#示例" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><p>官网的一些开发示例：<a href="https://www.rabbitmq.com/getstarted.html">RabbitMQ Tutorials</a></p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/tool/'>tool</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/rabbitmq/" class="post-tag no-text-decoration" >rabbitmq</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97+-+Chai+Yan&url=%2Ftool%2Fposts%2Fmessage_queue%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97+-+Chai+Yan&u=%2Ftool%2Fposts%2Fmessage_queue%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=%2Ftool%2Fposts%2Fmessage_queue%2F&text=%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97+-+Chai+Yan" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/tool/posts/mac_setup/">Mac 重装</a><li><a href="/linux/posts/locale/">Linux Locale</a><li><a href="/linux/posts/manjaro_i3/">Manjaro i3</a><li><a href="/board/bbb/posts/openwrt/">BeagleBone Black 安装 OpenWrt</a><li><a href="/collection/articles/posts/code/">编程</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/latex/">latex</a> <a class="post-tag" href="/tags/shell/">shell</a> <a class="post-tag" href="/tags/vim/">vim</a> <a class="post-tag" href="/tags/java8/">java8</a> <a class="post-tag" href="/tags/mac/">mac</a> <a class="post-tag" href="/tags/manjaro/">manjaro</a> <a class="post-tag" href="/tags/git/">git</a> <a class="post-tag" href="/tags/http/">http</a> <a class="post-tag" href="/tags/jekyll/">jekyll</a> <a class="post-tag" href="/tags/json/">json</a></div></div></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/tool/posts/eagle/"><div class="card-body"> <em class="small" data-ts="1558800000" data-df="ll" > May 26, 2019 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>PCB 工具</h3><div class="text-muted small"><p> Mac下的PCB工具没怎么用过，找到一款Eagle。 下载地址 下载安装好好，注册登陆就有这种非商业用途的免费License：EAGLE Free License For Non-Commercial Use And Evaluation Purposes。 一、教程 视频：Tutorial Series for CadSoft Eagle github：Eagle-Tutoria...</p></div></div></a></div><div class="card"> <a href="/tool/posts/vim/"><div class="card-body"> <em class="small" data-ts="1559923200" data-df="ll" > Jun 8, 2019 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>vim</h3><div class="text-muted small"><p> Vim 寄存器 :reg 可以查看 vim 寄存器的状态，寄存器编号以 &quot; 开始，后跟符号标记不同寄存器。 比较特殊的一个是 &quot;+ 寄存器，它表示系统的剪切板，所以如果需要从 vim 中拷贝内容到系统的剪切板，可以在 VISUAL 模式下，通过 &quot;+y 实现，相应的通过 &quot;+x 进行剪切。 Vim配置说明 syntax on &quot; 语法高亮 set nocompat...</p></div></div></a></div><div class="card"> <a href="/tool/posts/vim_usage/"><div class="card-body"> <em class="small" data-ts="1649692800" data-df="ll" > Apr 12, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Vim 使用</h3><div class="text-muted small"><p> Vim 使用笔记 [toc] 1. 启动 Vim vim -r file: 恢复上次异常退出的文件； vim + file: 从文件的末尾开始； vim +/string file: 打开 file，并将光标停留在第一个找到的 string 上； 2. 文档操作 :e – 重新加载当前文档； :e! – 重新加载当前文档，并丢弃已做的改动； :e fi...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/tool/posts/git_inner/" class="btn btn-outline-primary" prompt="Older"><p>Git 对象</p></a> <a href="/other/posts/chip_on_board/" class="btn btn-outline-primary" prompt="Newer"><p>Chip-On-Board</p></a></div></div></div><footer class="row pl-3 pr-3"><div class="col-12 d-flex justify-content-between align-items-center text-muted pl-0 pr-0"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://github.com/chaiyao0216">Chai Yan</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/latex/">latex</a> <a class="post-tag" href="/tags/shell/">shell</a> <a class="post-tag" href="/tags/vim/">vim</a> <a class="post-tag" href="/tags/java8/">java8</a> <a class="post-tag" href="/tags/mac/">mac</a> <a class="post-tag" href="/tags/manjaro/">manjaro</a> <a class="post-tag" href="/tags/git/">git</a> <a class="post-tag" href="/tags/http/">http</a> <a class="post-tag" href="/tags/jekyll/">jekyll</a> <a class="post-tag" href="/tags/json/">json</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
